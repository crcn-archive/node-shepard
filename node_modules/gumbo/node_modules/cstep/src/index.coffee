tq = require "tq"



tryInitializingCStep = (target) ->
  return target.cstep if target.cstep
  target.cstep = new CStep()


class CStep
  
  ###
    Function: 

    Parameters:
  ###

  constructor: () ->
    @_queue = tq.create().start()

  ###
    Function: 

    Parameters:
  ###

  add: (fnOrObj) ->

    # is it an object? then it's something like cstep(@).add(target)
    if typeof fnOrObj is "object"
      return @add (next) ->
        tryInitializingCStep(fnOrObj).add (parentNext) =>
          next()
          parentNext()



    # more than one function added?
    if arguments.length > 1
      for fn in arguments
        @add fn
      @

    # this will happen if step is called within a step function
    if not this._cqueue || this._calling
      @_cqueue = tq.create().start()
      @_callingStepper = false

    self = @

    @_cqueue.push (next) ->
      args = Array.prototype.slice.apply(arguments)

      # @ = next function
      args[fnOrObj.length - 1] = next

      # we're about to eneter an async function, so keep tabs on the OLD queue so we can
      # reset it *after* the async function is complete
      oldQueue = self._cqueue

      # flag the queue so that the current queue gets overwritten if another async function
      # is called within this one
      self._callingStepper = true

      fnOrObj.apply self, args

      # we've exited out of the function, so remove the dirty flag
      self._callingStepper = false

      self._cqueue = oldQueue;

    @





module.exports = (fnOrObj) ->
  
  # wrapping around an object instead of a function allows
  # for cstep to be initialized, and returned
  if typeof fnOrObj is "object"
    return tryInitializingCStep(fnOrObj)


  # return the function that shoves fn into a queue
  return () ->


    tryInitializingCStep @


    args = Array.prototype.slice.apply arguments
    tole = typeof args[args.length - 1]

    orgNext = null

    # if the last param is a function, then it's the callback function
    if tole == "function" || tole == "undefined"
      orgNext = args.pop()

    # org next doesn't exist? add a function that 
    # throws an error if one is returned - errors cannot be ignored
    if not orgNext
      orgNext = (err) ->
        if err then throw err

    called = false

    @cstep.add((next) =>

      args[fnOrObj.length - 1] = () =>
        if called
          throw new Error "cannot call cstep callback twice"
        called = true
        orgNext.apply @, arguments
        next()

      fnOrObj.apply this, args
    )

    @