{
  "name": "bindable",
  "version": "0.5.24",
  "description": "bindable.js ===========",
  "main": "./lib/index.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/classdojo/bindable.js.git"
  },
  "author": "",
  "license": "BSD",
  "readmeFilename": "README.md",
  "gitHead": "7edb2889d669a6f42b537b50772f9e86cf6337f1",
  "dependencies": {
    "dref": "0.1.x",
    "disposable": "0.0.x",
    "underscore": "~1.4.4",
    "hoist": "0.0.x",
    "toarray": "0.0.1",
    "outcome": "0.0.x",
    "type-component": "0.0.x",
    "async": "0.2.x",
    "protoclass": "0.0.5",
    "sift": "0.0.12"
  },
  "devDependencies": {
    "mocha": "1.8.x",
    "expect.js": "0.2.x",
    "structr": "0.2.x",
    "sift": "0.0.9",
    "sardines": "0.4.x",
    "karma": "0.8.x",
    "benchmark": "~1.0.0",
    "istanbul": "~0.2.1",
    "coveralls": "~2.6.0"
  },
  "readme": "# Bindable.js [![Alt ci](https://travis-ci.org/classdojo/bindable.js.png)](https://travis-ci.org/classdojo/bindable.js)\n\nIncredibly flexible bi-directional data binding library for `objects`, and `collections`. \n\n## Projects using bindable.js\n\n- [Paperclip.js](/classdojo/paperclip.js) - data-bindable templating engine.\n- [Linen.js](/classdojo/linen.js) - API library\n- [Sherpa.js](/classdojo/sherpa.js) - online tours library\n- [Mojo.js](/classdojo/mojo.js) - javascript framework.\n- [ECTwo](/crcn/node-ectwo)\n- [cortado](/crcn/cortado) - full integration testing framework. \n\n\n## BindableObject Example\n\n```javascript\nvar BindableObject = require(\"bindable\").Object;\n\nvar item = new BindableObject({\n  name: \"craig\",\n  last: \"condon\",\n  location: {\n    city: \"San Francisco\"\n  }\n});\n\nitem.bind(\"location.zip\", function(value) {\n  \n}).now();\n\n//triggers the binding\nitem.set(\"location.zip\", \"94102\"); \n\n\n\n//bind location.zip to another property in the model, and do it only once\nitem.bind(\"location.zip\", \"zip\").once().now();\n\n//bind location.zip to another object, and make it go both ways!\nitem.bind(\"location.zip\").to(anotherModel, \"location.zip\").bothWays().now();\n\n//chain to multiple items, and limit it!\nitem.bind(\"location.zip\").to(\"property\").to(\"anotherProperty\").to(function(value) {\n  \n}).limit(5).now();\n\nitem.bind({\n  property: \"location.zip\",\n  limit: 5,\n  to: \"anotherProperty\",\n  now: true\n})\n\n//you can even bind to values by setting a binding\nanotherModel.set(\"location.zip\", item.bind(\"location.zip\"));\n\n//you can also transform data as it's being bound\nitem.bind(\"name\").map(function(name) {\n  return name.toUpperCase()\n}).to(\"name2\").now();\n\n```\n\n## BindableCollection Example\n\n```javascript\nvar collection = new bindable.Collection([{ name: \"craig\" }, { name: \"sam\" }, { name: \"liam\" }]),\ncollection2 = new bindable.Collection();\n\n//binding to another collection, and transform that value into something else\ncollection.bind().map(function(item) {\n  return new BindableObject(item);\n}).to(collection2);\n\n//binding to a collection with a filter\ncollection.bind().filter({ name: {$nin: [\"craig\", \"liam\"] }}).to(collection2).now();\n\n\nvar source = [];\n\ncollection.bind(function(method, item, index) {\n  switch(method) {\n    case \"insert\": \n      source.splice(index, 0, item);\n    break;\n    case \"update\":\n    case \"replace\":\n      source.splice(index, 1, item);\n    break;\n    case \"remove\":\n      source.splice(index, 1);\n    break;\n  }\n});\n```\n\n## Iteration helper\n\n```javascript\nvar jake = new bindable.Object({\n  name: \"jake\",\n  age: 12\n});\n\nvar sam = new bindable.Object({\n  name: \"sam\",\n  age: 22\n});\n\nvar craig = new bindable.Object({\n  name: \"craig\",\n  age: 23\n});\n\nvar liam = new bindable.Object({\n  name: \"liam\",\n  friends: [jake, sam, craig],\n  getFriendsOlderThan20: bindable.computed(\"friends.@forEach.age\", function(next) {\n    this.get(\"friends\").filter(function(friend) {\n      return friend.get(\"age\") > 20;\n    }).forEach(next);\n  })\n});\n\n\nliam.bind(\"@getFriendsOlderThan20.name\").to(function(friendsOlderThan20) {\n  //[sam, craig]\n}).now();\n\njake.set(\"age\", 22);\n\n//callback friendsOlderThan20 = [sam, craig, jake]\n```\n\n\n## Computed Properties\n\n\n```javascript\nvar notification = new bindable.Object({\n  message: \"hello\",\n  read: false\n}),\nnotification2 = new bindable.Object({\n  message: \"hello 2\",\n  read: true\n});\n\nvar notifications = new bindable.Collection([notification, notification2]);\n\n//bind the number of unread notifications to numUnreadNotifications\nnotifications.bind(\"@each.read\").map(function(readNotifications) {\n  return readNotifications.filter(function(isRead) {\n    return !isRead;\n  }).length;\n}).to(\"numUnreadNotifications\").now();\n\nconsole.log(notifications.get(\"numUnreadNotifications\")); //1\n\nfor(var i = notifications.length(); i--;) {\n  notifications.at(i).set(\"read\", true);\n}\nconsole.log(notifications.get(\"numUnreadNotifications\")); //0\n\n```\n\n## Add some sugar...\n\nYou can also compute properties by watching multiple values. For instance:\n\n```javascript\n\nvar person = new bindable.Object({\n  firstName: \"John\",\n  lastName: \"Doe\"\n});\n\nperson.bind(\"firstName, lastName\").map({\n  to: function(firstName, lastName) {\n    return [firstName, lastName].join(\" \");\n  },\n  from: function(fullName) {\n    return String(fullName).split(\" \");\n  }\n}).to(\"fullName\").bothWays().now();\n\nconsole.log(person.get(\"fullName\")); //John Doe\nperson.set(\"fullName\", \"Jake Anderson\"); \nconsole.log(person.get(\"firstName\"), person.get(\"lastName\")); //Jake Anderson\n```\n\n\n## API\n\n\n### value bindable.get(property)\n\nReturns a property on the bindable object\n\n```javascript\nvar bindable = new bindable.Object({ city: { name: \"SF\" } });\n\nconsole.log(bindable.get(\"city.name\")); // SF\n```\n\n### bindable.set(property, value)\n\nSets a value to the bindable object\n\n```javascript\nvar obj = new bindable.Object();\nbindable.set(\"city.name\", \"sf\");\nconsole.log(obj.get(\"city.name\")); // SF\n```\n\n### bindable.has(property)\n\nReturns true if the bindable object has a given property\n\n```javascript\nvar obj = new bindable.Object({ count: 0, male: false, name: \"craig\" });\n\nconsole.log(obj.has(\"count\")); // true\nconsole.log(obj.has(\"male\")); // true\nconsole.log(obj.has(\"name\")); // true\nconsole.log(obj.has(\"city\")); // false\n```\n\n### Object bindable.context()\n\nreturns the context of the bindable object.\n\n```javascript\nvar context = {};\nvar obj     = new bindable.Object(context);\n\nconsole.log(obj.context() == context); // true\n```\n\n### bindable.dispose()\n\nEmits a `dispose` event, destroying all data-bindings and listeners on the given bindable object.\n\n```javascript\nvar obj = new bindable.Object({ name: \"craig\" });\n\nobj.bind(\"name\").to(\"name2\").now();\n\nconsole.log(obj.get(\"name2\")); // craig\n\nobj.dispose();\n\nobj.set(\"name\", \"abba\");\nconsole.log(obj.get(\"name2\")); // craig\n```\n\n### binding bindable.bind(from [, to])\n\nCreates a new binding object.\n\n```javascript\nvar obj = new bindable.Object({ name: \"craig\" });\n\n//bind to name2\nobj.bind(\"name\", \"name2\").now();\n\n//same as above, different style.\nobj.bind(\"name\").to(\"name2\").now();\n```\n\n### binding.to(targetOrFnOrProperty [, property])\n\nBinds to another object, or property.\n\n```javascript\nvar obj = new bindable.Object(),\nobj2    = new bindable.Object();\n\nobj.bind(\"name\").to(obj2, \"name\").now();\nobj.bind(\"name\").to(\"name2\").now();\n\nobj.set(\"name\", \"craig\");\nconsole.log(obj2.get(\"name\")); // craig\nconsole.log(obj.get(\"name2\")); // craig\n```\n\nBinding to a function:\n\n```javascript\nvar obj = new bindable.Object();\n\n//triggered after setting name\nobj.bind(\"name\").to(function (value, oldValue) {\n  console.log(value); // craig\n}).now();\n\nobj.set(\"name\", \"craig\"); // craig\n```\n\nYou can also chain `to` together:\n\n```javascript\nvar obj = new bindable.Object();\nobj.bind(\"name\").to(function(value, oldValue) {\n  console.log(value); // craig\n}).to(\"name2\").now();\n\nobj.set(\"name\", \"craig\");\nconsole.log(obj.get(\"name2\")); // craig\n```\n\n### binding.now()\n\nExecutes the binding now. For example:\n\n```javascript\nvar person = new bindable.Object({ name: \"craig\" });\n\n//only executes on change\nperson.bind(\"name\").to(\"name2\");\n\n//executes now, name must be present.\nperson.bind(\"name\").to(\"name3\").now();\n\nconsole.log(person.get(\"name2\")); // undefined\nconsole.log(person.get(\"name3\")); // craig\n\nperson.set(\"name\", \"john\"); \n\nconsole.log(person.get(\"name2\")); // john\nconsole.log(person.get(\"name3\")); // john\n```\n\n### binding.bothWays()\n\nbinds properties the other way around.\n\n```javascript\nvar person = new bindable.Object();\nperson.bind(\"name\").to(\"name2\").bothWays().now();\n\nperson.set(\"name\", \"craig\");\n\nconsole.log(person.get(\"name\")); // craig\nconsole.log(person.get(\"name2\")); // craig\n\nperson.set(\"name2\", \"john\");\n\nconsole.log(person.get(\"name\")); // john\nconsole.log(person.get(\"name2\")); // john\n```\n\n### binding.map(options)\n\nTransforms a value:\n\n```javascript\nvar person = new bindable.Object({ firstName: \"craig\", lastName: \"condon\" });\n\n//map TO fullName\nperson.bind(\"firstName, lastName\").map(function(firstName, lastName) {\n  return [firstName, lastName].join(\" \")\n}).to(\"fullName\").now();\n\nconsole.log(person.get(\"fullName\")); // craig condon\n```\n\nYou can also map from another value:\n\n```javascript\n\nvar person = new bindable.Object({ firstName: \"craig\", lastName: \"condon\" });\n\n//map TO fullName\nperson.bind(\"firstName, lastName\").map({\n  to: function(firstName, lastName) {\n    return [firstName, lastName].join(\" \")\n  },\n  from: function(fullName) {\n    return fullName.split(\" \");\n  }\n}).to(\"fullName\").bothWays().now();\n\nconsole.log(person.get(\"fullName\")); // craig condon\n\nperson.set(\"fullName\", \"john anderson\");\n\nconsole.log(person.get(\"firstName\")); // john\nconsole.log(person.get(\"lastName\")); // anderson\n```\n\n### binding.limit(count)\n\nLimits the number of times a binding ca be triggered.\n\n```javascript\nvar person = new bindable.Object();\nperson.bind(\"count\").to(\"count2\").limit(2).now();\n\nperson.set(\"count\", 1);\nconsole.log(person.get(\"count2\")); // 1\nperson.set(\"count\", 2);\nconsole.log(person.get(\"count2\")); // 2\nperson.set(\"count\", 3);\nconsole.log(person.get(\"count2\")); // 2\n```\n\n### binding.once()\n\nTriggers the binding once.\n\n```javascript\nvar person = new bindable.Object({ name: \"craig\" });\nperson.bind(\"name\").map(function(name) {\n  return name.toUpperCase();\n}).to(\"nameUpper\").once().now();\n\nconsole.log(person.get(\"nameUpper\")); // CRAIG\nperson.set(\"name\", \"john\"); // not triggered\nconsole.log(person.get(\"nameUpper\")); // CRAIG\n```\n\n\n### binding.dispose()\n\nDisposes the binding.\n\n```javascript\nvar person = new bindable.Object({ name: \"craig\" });\nperson.bind(\"name\").to(\"name2\").now().dispose();\n\nconsole.log(person.get(\"name2\")); // craig\nperson.set(\"name2\", \"john\");\nconsole.log(person.get(\"name2\")); // craig\n```\n\n\n## Chaining\n\nbindable.js allows you to easily chain bindings together. Here are a few examples\n\n```javascript\nvar person = new bindable.Object();\n\n//bind property to multiple values. Run through multiple mappers.\nperson.bind(property).map(fn).to(value).map(fn2).to(anotherValue).now()\n```",
  "bugs": {
    "url": "https://github.com/classdojo/bindable.js/issues"
  },
  "_id": "bindable@0.5.24",
  "dist": {
    "shasum": "f8053aca311cd6c4b90dd52aaa0f3bc825931a65"
  },
  "_from": "bindable@0.5.x",
  "_resolved": "http://registry.npmjs.org/bindable/-/bindable-0.5.24.tgz"
}
